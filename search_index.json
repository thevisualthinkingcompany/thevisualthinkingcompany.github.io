[["index.html", "Random Location 1 Introduction", " Random Location Your Name 2025-01-28 1 Introduction Lorem ipsem dolor est… "],["polygon-processing.html", "2 Polygon Processing 2.1 Polygons Imports 2.2 SQL Prep 2.3 WKT geometry 2.4 Query 2.5 Leaflet Example", " 2 Polygon Processing 2.1 Polygons Imports In many cases, simply using read_sf() will work, but this function ensures we avoid many of the common issues with many polygon downloads. It’s useful for leaflet foremost, but standardizing the CRS and dimension count also avoids many basic geoprocessing errors which can be annoying to troubleshoot. Read polygons with sf package (which automatically interprets file type), or interpret the WKT into geometry, depending on input. read_sf() will generally be used for processing outside geodata, and WKT will generally be used from queries to our database. Remove 3rd z-dimension if present (often default exports create an empty or zero value for this column; leaflet can’t use polygons with it, even when empty) Ensure we’re using “Web CRS read_polygons &lt;- function(data_file){ if (is.character(data_file)) { sf &lt;- read_sf(data_file) } else if (is.data.frame(data_file) &amp;&amp; &quot;Geometry_WKT&quot; %in% colnames(data_file)) { sf &lt;- st_as_sf(data_file, wkt = &quot;Geometry_WKT&quot;) } else { stop(&quot;Input must be either a file path or a data.frame with a &#39;Geometry_WKT&#39; column.&quot;) } flat &lt;- st_zm(sf,drop=TRUE) if (st_crs(flat)$epsg != 4326) { flat &lt;- st_transform(flat, crs = 4326) } return(flat) } 2.2 SQL Prep 2.2.1 Bounder The bounder gives us ready access to the bounding box of the polygons, as well its centre-point. Technically, the bounding box is created with the corners (eg, Bound_North by Bound_East is the North-East corner), but using bounding longitudinal and latitudinal lines allows for quicker filtering via basic dataframe functions, without interpreting a two-dimension coordinate. bound_polygons &lt;- function(sf_object, geometry_column = &quot;Geometry&quot;) { sf_object &lt;- sf_object %&gt;% st_set_geometry(geometry_column) sf_object &lt;- sf_object %&gt;% mutate( Bound_North = map_dbl(!!sym(geometry_column), ~ st_bbox(.x)[&quot;ymax&quot;]), Bound_South = map_dbl(!!sym(geometry_column), ~ st_bbox(.x)[&quot;ymin&quot;]), Bound_East = map_dbl(!!sym(geometry_column), ~ st_bbox(.x)[&quot;xmax&quot;]), Bound_West = map_dbl(!!sym(geometry_column), ~ st_bbox(.x)[&quot;xmin&quot;]), Centre_Lat = map_dbl(!!sym(geometry_column), ~ st_coordinates(st_centroid(.x))[2]), Centre_Lng = map_dbl(!!sym(geometry_column), ~ st_coordinates(st_centroid(.x))[1]) ) return(sf_object) } 2.3 WKT geometry Well-known-text allows to save and read the geometry (series of coordinates creating nodes and lines) in a simple dataframe without necessarily interpreting, saving, downloading as geodata. WKT_polygons creates WKT geodata. To read WKT, use read_polygons which has a built-in check for WKT-data input WKT_polygons &lt;- function(sf_object, geometry_column = &quot;Geometry&quot;) { sf_object &lt;- sf_object %&gt;% st_set_geometry(geometry_column) sf_object &lt;- sf_object %&gt;% mutate( Geometry_WKT = st_as_text(!!sym(geometry_column)) ) return(sf_object) } 2.4 Query 2.4.1 Leaflet Bounding Box (View Box) Filters 2.4.1.1 Filters Generate a where clause based on bounding lines. Greedy finds a polygons that are partially OR wholly within the bounding box. The query north bound is above the polygon’s south bound and the query south bound is below the polygons north bound: This is only false if the polygon’s bounding box is entirely above or below the query bounding box. Shy finds polygons that are ONLY wholly within the bounding box. The query north bound is above the polygon’s north bound and the query south bound is below the polygon’s south bound: This is false even if the bounding boxes overlap; it is only true when all corners of the polygon’s bounding box are within the corners of the query bounding box. ^This may leave some empty spaces at the edges of the map frame, or, rarely, large missed polygons with odd, long juts. The problem is minimal when the map zoom is relatively far out compared to the average polygon size; in such a case, you’d likely be loading many polygons so the relatively small missed-polygons are a worthwhile cost for speed/data costs. The problem is pronounced when you’re very zoomed in; at the extreme, if you zoom in entirely on a polygon or on the border of two polygons, both of them would be filtered out! Therefore, greedy should be used when zooms are relatively low, and shy should be used when zooms are relatively high. Central is a happy medium. See Dynamic Filter for a way to adjust display polygons in shiny to the zoom level. Central finds polygons with a centre point within the bounding frame. This will grab everything that Shy grabs (if all four corners are within the bounding frame, of course the centre is as well) and has the potential to grab some polygons which Shy will not (especially large polygons, or ones with odd, long juts which may be largely within the bounding frame with some corner outside for whatever reason). In cases where only a small portion of the polygon would be in frame, it will still load slightly fewer polygons than Greedy. Point uses the central filter on our standard point data columns, to avoid confusion / avoid a duplicate function All these filter_types have four WHERE conditions so are not faster in terms of query searching, but Shy is faster than Central and Central is faster than Greedy in terms of downloading and mapping/loading that queried data (in so far as they return TRUE for fewer polygons). bbox_filter &lt;- function(lat_min, lat_max, lng_min, lng_max, filter_type = &quot;greedy&quot;) { if (filter_type == &quot;greedy&quot;) { where_clause &lt;- sprintf( &quot;WHERE Bound_North &gt; %f AND Bound_South &lt; %f AND Bound_East &gt; %f AND Bound_West &lt; %f&quot;, lat_min, lat_max, lng_min, lng_max ) } else if (filter_type == &quot;shy&quot;) { where_clause &lt;- sprintf( &quot;WHERE Bound_North &lt;= %f AND Bound_South &gt;= %f AND Bound_East &lt;= %f AND Bound_West &gt;= %f&quot;, lat_max, lat_min, lng_max, lng_min ) } else if (filter_type == &quot;central&quot;) { where_clause &lt;- sprintf( &quot;WHERE Centre_Lat &gt;= %f AND Centre_Lat &lt;= %f AND Centre_Lng &gt;= %f AND Centre_Lng &lt;= %f&quot;, lat_min, lat_max, lng_min, lng_max ) } else if (filter_type == &quot;point&quot;) { where_clause &lt;- sprintf( &quot;WHERE lat &gt;= %f AND lat &lt;= %f AND lng &gt;= %f AND lng &lt;= %f&quot;, lat_min, lat_max, lng_min, lng_max ) }else { stop(&quot;Invalid filter_type specified.&quot;) } return(where_clause) } 2.4.1.2 Shiny Example Example of live updating polygon layer in a shiny app, where a map has been created as mapname &lt;- leaflet()… ##### ##### Dummy / empty polygon, used to avoid crash on start when query incomplete ##### dummy_polygon &lt;- st_polygon(list(rbind( c(-123.0001, 49.0001), # Top-left c(-123.0001, 49.0000), # Bottom-left c(-123.0000, 49.0000), # Bottom-right c(-123.0000, 49.0001), # Top-right c(-123.0001, 49.0001) # Closing the polygon (back to top-left) ))) # Create an sf object with this geometry empty_sf &lt;- st_sf( Bound_North = 49.0001, Bound_South = 49.0000, Bound_East = -123.0000, Bound_West = -123.0001, Centre_Lat = 49.00005, Centre_Lng = -123.00005, Geometry_WKT = st_sfc(dummy_polygon) ) ##### ##### Live updating display polygons ##### #Generally, it&#39;s better to have the bounds stored in a separate reactive or reactval, #so you&#39;re not calculating multiple times when filtering multiple datasets polygons_to_map &lt;- reactive({ bounds &lt;- input$mapname_bounds if (is.null(bounds)) { return(empty_sf) # Return empty sf object initially, avoids crash on start } some_query_function(..., &quot;SELECT *&quot;, &quot;FROM table&quot;, bbox_filter(bounds$south, bounds$north, bounds$west, bounds$east) # ^ Returns WHERE... AND ... AND ... AND ... statement ) }) #Update map based on new bounding box / filtering observe({ leafletProxy(&quot;mapname&quot;) %&gt;% clearShapes() %&gt;% #can clear a group instead to be more precise addPolygons(data = polygons_to_map()$Geometry_WKT, color = &quot;blue&quot;, weight = 2, opacity = 0.5, fillOpacity = 0.2) }) 2.4.1.3 Dynamic Filtering (Shiny) Method to use the most optimal filter (speed / gaps tradeoff) for different zoom levels. Simply use an if statement taking the zoom as input, selecting a different filter_type. pick_polygon_filter_type &lt;- function(zoom_level, high_cutoff, mid_cutoff, low_cutoff, off_cutoff){ if (zoom_level &gt;= high_cutoff) { # Use greedy filter at higher zoom levels filter_to_use &lt;- &quot;greedy&quot; } else if (zoom_level &gt;= mid_cutoff) { filter_to_use &lt;- &quot;central&quot; } else if (zoom_level &gt;= low_cutoff) { # Use shy filter at lower zoom levels filter_to_use &lt;- &quot;shy&quot; } else if (zoom_level &gt;= off_cutoff) { # Don&#39;t Query Anything filter_to_use &lt;- &quot;hide&quot; } else { NULL } return(filter_to_use) } polygons_to_map &lt;- reactive({ zoom_level &lt;- input$mapname_zoom bounds &lt;- input$mapname_bounds if (is.null(bounds) || is.null(zoom_level)) { return(empty_sf) } filter_to_use &lt;- pick_polygon_filter_type(zoom_level, 14, 10, 7, 0) if (filter_to_use == &quot;hide&quot;){ return(empty_sf) } else{ some_query_function(..., &quot;SELECT *&quot;, &quot;FROM table&quot;, bbox_filter(bounds$south, bounds$north, bounds$west, bounds$east, filter_type = filter_to_use) ) } }) 2.4.2 Engulfing Filter Generates a where condition to find polygons that a given point is within. * Without Shiny, we can just import all the polygons and use st_within * With Shiny, using a user click as the input point, it’s faster to first query for polygons within the map view box, since we know the click must have been inside there, so we know only polygons which pass a Greedy filter could possibly “engulf” (our name for the inverse of “within”) the point. # Find polygons within map view box, #as in the Leaflet Bounding Box Filters, Shiny Example (above) find_engulfing_polygons &lt;- function(click_lat, click_lng, polygons) { point &lt;- st_sfc(st_point(c(lng, lat)), crs = st_crs(polygons)) polygons_engulfing &lt;- polygons %&gt;% filter(map_lgl(Geometry_WKT, ~ st_within(point, .x, sparse = FALSE))) return(polygons_engulfing) } Shiny example # Find polygons within map view box, #as in the Leaflet Bounding Box Filters, Shiny Example (above) # polygons_to_map &lt;- ... observeEvent(input$mapname_click, { click &lt;- input$mapname_click if (is.null(click)) return() click_lat &lt;- click$lat click_lng &lt;- click$lng polygons_engulfing &lt;- find_engulfing_polygons(click_lat, click_lng, polygons_to_map) }) #Alternatively, if you have no other use for the polygons_to_map, #you could put that filter process just above the polygons_engulfing &lt;- ... 2.5 Leaflet Example leaflet() %&gt;% addTiles() "],["random-location.html", "3 Random Location 3.1 Set Up 3.2 Example", " 3 Random Location 3.1 Set Up # Load the leaflet library library(leaflet) library(tidyverse) 3.2 Example 3.2.1 Satellite random_lat &lt;- runif(1, min = 48.3, max = 60.0) random_lng &lt;- runif(1, min = -139.0, max = -114.0) random_zoom &lt;- runif(1, min = 8, max = 10) leaflet() %&gt;% addProviderTiles(providers$Esri.WorldImagery) %&gt;% setView(lng = random_lng, lat = random_lat, zoom = random_zoom) %&gt;% addMarkers(lng = random_lng, lat = random_lat, popup = &quot;Random Location in BC&quot;) 3.2.2 Street random_lat &lt;- runif(1, min = 48.3, max = 60.0) random_lng &lt;- runif(1, min = -139.0, max = -114.0) random_zoom &lt;- runif(1, min = 8, max = 10) leaflet() %&gt;% addTiles() %&gt;% setView(lng = random_lng, lat = random_lat, zoom = random_zoom) %&gt;% addMarkers(lng = random_lng, lat = random_lat, popup = &quot;Random Location in BC&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
